<h5>Euismod Aenean Ornare Malesuada Inceptos</h5>
<pre class="prettyprint linenums"><code>
<span class="pln">class </span><span class="kwd">BinaryTree</span>
  <span class="atn">attr_accessor</span> <span class="atv">:value, :right_branch, :left_branch</span>

  <span class="pln">def</span> <span class="typ">initialize(value)</span>
    <span class="pln">@value = value
    @left_branch = nil
    @right_branch = nil
  end</span>
  
  def insert(value)
    if value > @value
      @right_branch ? @right_branch.insert(value) : @right_branch = BinaryTree.new(value)
    elsif value < @value
      @left_branch ? @left_branch.insert(value) : @left_branch = BinaryTree.new(value)
    else
       'world ends'
    end
  end
<span class="kwd">end</span></code></pre>



<!-- Inline images for post-content -->
<img class="inline-image left-align" src=""/>
<img class="inline-image right-align" src=""/>

<p class="lead">We make this a class method so when the endpoint receives the GET request, we can call <code class="inline">Amazon.get_s3_upload_key</code> and render the returned hash into json by the controller. The hash generated will consist of 4 objects:</p>
<ol>
  <li>Your access key (obtained through AWS,</li>
  <li>A secure, random key that will be the url of the s3 object,</li>
  <li>The policy, Base64 encoded, and</li>
  <li>The signature, a Base64 encoded policy hashed with your AWS secret key.</li>
</ol>


<p class="lead">The key is generated by ruby's built in secure random number generator interface. The result will be appended onto the bucket url and ultimately form the url for the s3 object.</p>
<pre><code>
  <span class="met">SecureRandom.uuid</span> <span class="com">#=> 2d931510-d99f-494a-8c67-87feb05e1594</span>
</code></pre>

<p class="lead">The policy is Base64 encoded and must consist (at-least) of the following elements:</p>

<h2 class="lead">Expiration (Time Object)</h2>
<p>
  <pre><code>
    <span class="met">30.minutes.from_now.utc.strftime('%Y-%m-%dT%H:%M:%S.000Z) <span class="com">#=> 2014-12-20T23:07:16.000Z</span>
  </code></pre>
</p>

<h2>Conditions: an array of objects</h2>
<p>bucket: &lt;your s3 bucket name&gt; I set this as a global environment variable and then interpolate the value into a string.</p>
<p>
  <pre><code>
  <span class="met">'bucket':</span><span class="met">'</span><span class="plain">#{</span><span class="met">ENV['S3_BUCKET_NAME']</span><span class="plain">}</span><span>'</span>
  </code></pre>
</p>

<p></p>
'starts-with': the SecureRandom key that you generated.
<pre><code>
  'starts-with', '$key', '#{@key}'
</code></pre>
  acl: Access control list. This value determines how the object will be accessed. In our case, we want the object to public readable.
  'starts-with', '$Content-Type: this value tells s3 what type of file to expect. In our case, only images. The value

<pre><code>
class Amazon
  def self.get_s3_upload_key
    @key = "uploads/#{SecureRandom.uuid}"
    @policy = Base64.encode64(
      "{'expiration': '#{30.minutes.from_now.utc.strftime('%Y-%m-%dT%H:%M:%S.000Z')}',
      'conditions': [
        {'bucket': '#{ENV['S3_BUCKET_NAME']}'},
        ['starts-with', '$key', '#{@key}'],
        {'acl': 'public-read'},
        ['starts-with', '$Content-Type', 'image/jpeg'],
        ['content-length-range', 0, 10485760],
      ]}").gsub(/\n|\r/, '')
    @signature = Base64.encode64(OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha1'), ENV['AWS_SECRET_ACCESS_KEY'], @policy)).gsub(/\n| |\r/, '')
    return {access_key: ENV['AWS_ACCESS_KEY_ID'], key: @key, policy: @policy, signature: @signature}
  end
end
</code></pre>

<pre><code>
class AmazonController < ApplicationController
  def sign_key
    response = Amazon.get_s3_upload_key
    render json: response, status: 200
  end
end
</code></pre>
